{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
\margl1440\margr1440\vieww15140\viewh9920\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 The first part of this challenge was to implement a function that will pull in all the details of ERC20 token transfers given a certain block. My code, written in python, queries Infura with the \'91eth_getlogs\'92 json_rpc, searching for the LogFill event that is triggered from the successful transfer action of tokens on the 0x contract. It searches for the log fill with the variable q and the block number based, and then outputs a CSV with certain fields including Maker, and Taker (which can be contracts), the token and Token Type, all in my output.txt are of type _zrxToken, and the protocol used. \
\
In reference to part 2 of this assignment:\
It would be highly challenging to front-run ethereum erc20 token transfer in the classical sense for many reasons which I will attempt to briefly outline here. For one, this methodology of querying Infura would offer no market edge to anyone trying to seek an advantage over their competitors. Infura hosts a large swath of nodes, which at times can make up a fairly large portion of the total EVM (at times they said above 5% or more). If an attacker were trying to query from Infura they would currently be using a get call, they trying to out-edge a node that might be slower to direct a buy or sell order of a certain token, beating the market price by speed alone. Due to the way the propagation of block verification currently exists this would be extremely difficult and a brute force attack would almost certainly be deemed a stale block at best and reward the attacker with nothing. Additionally, Infura is moving to a web sockets format wherein finalized information from their portion of the EVM will be pushed to the clients, meaning when an attempted attacker had market information so would everyone else waiting for that event. \
\
Any of the remaining opportunity for front-running is further mitigated by use of 0x protocols. The way in which a potential attack targeted digital currencies in the past was that they themselves might be the exchange, quickly acting to process orders in their favor before the marker could know what happened, sometimes internally. This was due to what seemed like a more open market on the outside but really had very minimally transparent log. 0x protocol can mitigate that issue by making all logs off chain and able to be audited. Relayers do not even truly make markets, \'93\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Relayers can only recommend a best available price to Takers who must then independently decide to sign and send the transaction to the blockchain\'94. This means that it is really up to the signer of a transfer to agree, no longer the exchange mechanism. Furthermore 0x protocols are possibly smart contract in themselves, entirely open to audit and merely acting as a source of quite temporary arbitrage. So the method of order routing in which I, as a potential attacker, would listen to the events of \'93quick\'94 node and try to then send a new order through a location that is \'93slower\'94 (i.e., using an earlier protocol, or somehow uses a less technologically up to date miner, etc) is entirely up to the market at that other location, which would then have to agree to my trumped up price anyway. }